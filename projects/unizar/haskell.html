<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Renderizado ‚Äî Path Tracer & Photon Mapper</title>
  <link rel="stylesheet" href="../../css/styles.css">
  <link rel="stylesheet" href="../../css/project-styles.css">
  <meta name="description" content="Implementaci√≥n en Haskell de un Path Tracer y un Photon Mapper. BVH, KDT, concurrencia y optimizaciones para generar im√°genes fotorrealistas y c√°usticas. Documentaci√≥n larga y detallada." />
</head>
<body>
  <header>
        <nav class="navbar">
            <div class="logo">
                <span class="bracket">&lt;</span>
                <span class="logo-text">Gr√°fica</span>
                <span class="bracket">/&gt;</span>
            </div>
            <ul class="nav-links">
                <li><a href="../../index.html" class="nav-link">‚Üê Volver al Portfolio</a></li>
            </ul>
            <button class="theme-toggle" id="themeToggle" aria-label="Cambiar tema">
                <span class="icon">‚òÄ</span>
            </button>
        </nav>
    </header>

  <section class="project-hero">
    <div class="project-header">
      <a href="../../index.html#proyectos" class="back-link">‚Üê Volver a Proyectos</a>
      <h1 class="project-title">Path Tracer &amp; Photon Mapper con Haskell</h1>

      <div class="project-meta">
        <div class="meta-item">üìÖ Diciembre 2023 ‚Äî Mayo 2024</div>
        <div class="meta-item">‚è±Ô∏è Duraci√≥n: ~6 meses (iterativo)</div>
        <div class="meta-item">üë• Pr√°ctica de Inform√°tica Gr√°fica ‚Äî Implementaci√≥n en <strong>Haskell</strong></div>
      </div>

      <div class="project-links">
        <a href="https://github.com/J-solan/grafica" class="btn btn-primary" target="_blank">üìÇ Ver en GitHub</a>
        <a href="/J-solan.github.io/assets/pdfs/pathtracer.pdf" class="btn btn-secondary" target="_blank">üìÑ PathTracer (PDF)</a>
        <a href="/J-solan.github.io/assets/pdfs/photonmapping.pdf" class="btn btn-secondary" target="_blank">üìÑ PhotonMapper (PDF)</a>
      </div>

      <div class="tech-list">
        <span class="tech-item">Haskell</span>
        <span class="tech-item">BVH / K-D Tree</span>
        <span class="tech-item">Concurrente / Distribuido</span>
        <span class="tech-item">Monte Carlo, MIS, NEE</span>
        <span class="tech-item">PPM / BMP outputs, scripts de orquestaci√≥n</span>
      </div>
    </div>
  </section>

  <main class="project-content">

    <section class="content-section">
      <h2>üìù Resumen</h2>
      <p>
        Este trabajo presenta una implementaci√≥n completa y detallada de dos t√©cnicas cl√°sicas de renderizado: <strong>Path Tracing</strong> y <strong>Photon Mapping</strong>, desarrolladas √≠ntegramente en Haskell. Mientras que la mayor√≠a de la asignatura y ejemplos habituales estaban en C/C++, fuimos el primer equipo en implementar la pr√°ctica completa en Haskell ‚Äî aprovechar la pureza, tipado y expresividad del lenguaje nos permiti√≥ dise√±ar un c√≥digo limpio y con menos errores de memoria, manteniendo un rendimiento competitivo mediante optimizaciones cuidadosas.
      </p>
      <p>
        La p√°gina recoge: dise√±o algor√≠tmico, decisiones de implementaci√≥n, aspectos f√≠sicos y matem√°ticos relevantes (radiometr√≠a b√°sica, ecuaci√≥n de render, BRDFs), optimizaciones (BVH, K-D tree para fotones), paralelizaci√≥n local y distribuci√≥n simple, detalles experimentales y un apartado reproducible para ejecutar y comparar escenas y benchmarks.
      </p>
    </section>

    <section class="content-section">
      <h2>üéØ Objetivos</h2>
      <ul>
        <li>Implementar un Path Tracer capaz de manejar materiales difusos, especulares y refractivos con muestreo Monte Carlo.</li>
        <li>Implementar un Photon Mapper para capturar c√°usticas y mejorar la estimaci√≥n local de energ√≠a incidente.</li>
        <li>Optimizar el rendimiento mediante estructuras de aceleraci√≥n (BVH) y paralelizaci√≥n en Haskell.</li>
        <li>Comparar resultados y documentar trade-offs: ruido vs sesgo, tiempo de render vs calidad.</li>
        <li>Garantizar reproducibilidad: scripts de build, par√°metros y escenas listadas.</li>
      </ul>
    </section>

    <section class="content-section">
      <h2>üî¨ Fundamentos f√≠sicos y matem√°ticos b√°sicos (lo que explicamos en los PDFs)</h2>

      <h3>Radiometr√≠a simplificada</h3>
      <p>
        Para que el lector no pierda el hilo, incluimos una breve revisi√≥n de conceptos usados en el c√≥digo:
      </p>
      <ul>
        <li><strong>Radiancia (L):</strong> potencia por unidad de √°rea proyectada por unidad de √°ngulo s√≥lido. Es la magnitud que permanece invariante a lo largo de un rayo en medios no absorbentes y es la que integra la c√°mara para obtener p√≠xeles.</li>
        <li><strong>Flujo (Œ¶):</strong> energ√≠a total por unidad de tiempo emitida por una fuente.</li>
        <li><strong>Irradiancia (E):</strong> potencia incidente por unidad de √°rea. En photon mapping estimamos esta cantidad localmente mediante densidad de fotones.</li>
      </ul>

      <h3>Ecuaci√≥n de render (Kajiya) ‚Äî forma pr√°ctica</h3>
      <p>
        La ecuaci√≥n integral de render describe la radiancia saliente como la suma de emisi√≥n propia y la integral sobre la esfera de direcciones de la radiancia entrante modulada por la BRDF y por el t√©rmino cos(Œ∏):
      </p>
      <pre><code> L_o(x, œâ_o) = L_e(x, œâ_o) + ‚à´_{Œ©} f_r(x, œâ_i, œâ_o) L_i(x, œâ_i) cosŒ∏_i dœâ_i
</code></pre>
      <p>
        En el Path Tracer aproximamos esta integral mediante muestreo Monte Carlo (caminos aleatorios). En Photon Mapping, la primera pasada (mapa de fotones) aproxima la contribuci√≥n de la integral mediante acumulaci√≥n y posterior estimaci√≥n de densidad en k vecinos o radio fijo.
      </p>

      <h3>BRDFs y fen√≥menos √≥pticos</h3>
      <p>
        Se implementaron BRDFs b√°sicos y extensiones:
      </p>
      <ul>
        <li><strong>Lambertiano:</strong> difuso ideal, muestreo proporcional al coseno.</li>
        <li><strong>Phong / Blinn-Phong:</strong> modelo emp√≠rico para especulares (implementado para comparaci√≥n).</li>
        <li><strong>Dielectric:</strong> reflexi√≥n y refracci√≥n con Fresnel (Schlick aprox.).</li>
        <li><strong>Bump mapping:</strong> perturbaci√≥n de normales para simular detalle sin aumentar la geometr√≠a.</li>
      </ul>

      <h3>Mu√©strame uno de los PDFs (resumen):</h3>
      <p>El PDF de <em>pathtracer</em> describe el muestreo de importancia, ruleta rusa, next-event-estimation, c√°maras con apertura y generaci√≥n de m√∫ltiples rayos por p√≠xel (samples per pixel). El PDF de <em>photonmapping</em> documenta la fase de emisi√≥n de fotones, construcci√≥n del k-d tree y la estimaci√≥n de densidad con distintos kernels, adem√°s de pruebas anal√≠ticas sobre el sesgo introducido por el radio fijo.</p>
    </section>

    <section class="content-section">
      <h2>üõ†Ô∏è Metodolog√≠a y extras implementados (detallado)</h2>

      <h3>Path Tracer ‚Äî detalles extras</h3>
      <ul>
        <li><strong>Muestreo y MIS:</strong> combinamos t√©cnicas de muestreo (sampling de BRDF y muestreo directo de luz) usando Multiple Importance Sampling para reducir varianza en escenas con luces intensas y peque√±as √°reas emisoras.</li>
        <li><strong>Next-Event-Estimation (NEE):</strong> para luz directa se realiza un muestreo expl√≠cito hacia las luces, con visibilidad test para evitar contribuciones ocultas y con pesos MIS.</li>
        <li><strong>Russian Roulette:</strong> t√©cnica para limitar la profundidad media de muestreo adaptando la probabilidad de supervivencia al albedo del material.</li>
        <li><strong>C√°mara f√≠sica:</strong> implementaci√≥n de apertura (depth of field) y exposici√≥n para simular √≥pticas reales.</li>
        <li><strong>Soporte de texturas UV y mapas normales:</strong> texturizado de esferas, tri√°ngulos y rect√°ngulos, con parsing simple de BMP para texturas.</li>
      </ul>

      <h3>Photon Mapping ‚Äî detalles extras</h3>
      <ul>
        <li><strong>Emisi√≥n de fotones:</strong> energ√≠a por fot√≥n proporcional a la potencia de la luz. Se guarda posici√≥n, direcci√≥n y energ√≠a del fot√≥n en una lista antes de construir el k-d tree.</li>
        <li><strong>K-D Tree y consultas:</strong> utilizamos la librer√≠a kdt de Haskell para construir una estructura est√°tica optimizada y realizar b√∫squedas k-NN y radius queries con backend en vectores estrictos para rendimiento.</li>
        <li><strong>Kernels de estimaci√≥n:</strong> soporte para kernel constante (box), epanechnikov (cuadr√°tico) y un kernel gaussiano aproximado. Se comparan en el PDF trade-offs entre ruido y suavidad.</li>
        <li><strong>Filtrado espacial:</strong> para evitar contaminaci√≥n entre objetos se filtran fotones por ID de objeto/normal para usar solo fotones que realmente pertenecen a la superficie local.</li>
        <li><strong>Photon Mapping h√≠brido:</strong> combinaci√≥n de photon-map + path-tracing para materiales especulares donde el photon map ayuda a converger en c√°usticas.</li>
      </ul>

      <h3>Medios participativos y muestreo avanzado</h3>
      <p>
        Incluimos soporte b√°sico para medios homog√©neos (niebla). Para el muestreo de transmittancia se documenta la aproximaci√≥n usada (exponencial) y la posibilidad de usar Equiangular Sampling y Volumetric Next Event Estimation como extensi√≥n futura.
      </p>

      <h3>Optimizaci√≥n y paralelismo en Haskell</h3>
      <p>
        Implementar en Haskell requiri√≥ decisiones concretas para obtener rendimiento:
      </p>
      <ul>
        <li><strong>Estructuras estrictas:</strong> uso de vectores unboxed y patrones '!' (bang patterns) para evitar retenci√≥n de thunks en loops cr√≠ticos.</li>
        <li><strong>Parallel/async:</strong> se us√≥ la librer√≠a <code>async</code> y <code>Control.Parallel.Strategies</code> para dividir el render por tiles y consolidar resultados eficientemente.</li>
        <li><strong>Memory layout:</strong> BVH con arrays contiguos para nodos; fotones almacenados en vectores y reconstrucci√≥n en paralelo del k-d tree.</li>
        <li><strong>Interoperabilidad y scripts:</strong> scripts de orquestaci√≥n en Bash y Ruby para distribuci√≥n por SSH (modelo maestro/worker) y utilidades para convertir PPM‚ÜíPNG.</li>
      </ul>

      <p>
        Estas elecciones permitieron que, aun con la sobrecarga de un lenguaje de alto nivel, los tiempos de render fuesen comparables con implementaciones sencillas en C++ y con ventaja en seguridad de c√≥digo y facilidad para razonar sobre invariantes.
      </p>
    </section>

    <section class="content-section">
      <h2>‚öôÔ∏è Implementaci√≥n ‚Äî estructura del repositorio y comandos</h2>
      <p>Resumen r√°pido de c√≥mo est√° organizado el repo y comandos para reproducir:</p>
      <pre><code># Compilar (stack o cabal)
stack build --fast
# Renderizar escena de ejemplo (scene1.cfg)
stack exec grafica -- --scene scenes/scene1.cfg --width 1024 --height 768 --spp 256 --output out/scene1.ppm
# Ejecutar photon mapping (dos fases)
stack exec grafica -- --mode photons --scene scenes/caustic.cfg --nphotons 500000
stack exec grafica -- --mode render --scene scenes/caustic.cfg --use-photon-map out/photons.kdt --spp 64
</code></pre>

      <p>En el PDF y en el README del repositorio est√°n todas las escenas, par√°metros y formatos de fichero descritos (archivos .cfg sencillos para reproducir condiciones experimentales).</p>
    </section>

    <section class="content-section">
      <h2>üìä Resultados y benchmarking (detallado)</h2>
      <p>
        Incluimos comparativas visuales (en el PDF) y m√©tricas num√©ricas: SNR aproximado por tiempo, convergencia por muestras por p√≠xel, tiempo total por escena en hardware de pruebas (Intel i7, 16GB RAM). A modo de resumen:
      </p>
      <ul>
        <li>BVH reduce coste de intersecci√≥n en escenas complejas ~4‚Äì12√ó dependiendo de la distribuci√≥n de tri√°ngulos.</li>
        <li>Photon Mapping mejora notablemente representaci√≥n de c√°usticas versus path tracing puro con un coste adicional en memoria y tiempo durante la fase de emisi√≥n.</li>
        <li>Paralelizar por tiles escala bien hasta el n√∫mero de n√∫cleos l√≥gicos; la distribuci√≥n por SSH aporta beneficios si hay varias m√°quinas con CPU disponible, aunque el overhead de transferencia y sincronizaci√≥n limita la eficiencia si las m√°quinas son lentas en I/O.</li>
      </ul>

      <p>
        En la carpeta <code>benchmarks/</code> del repo est√°n los scripts y los logs de ejecuci√≥n. Los PDFs incluyen las im√°genes comparativas para inspecci√≥n visual de ruido/c√°usticas/gamma-correction.
      </p>
    </section>

    <section class="content-section">
      <h2>üß© Galer√≠a (ejemplos destacados)</h2>
      <p>
        (En la versi√≥n del repositorio hay una carpeta <code>renders/</code> con los PNGs exportados. Aqu√≠ apuntamos a las m√°s relevantes):
      </p>
      <ul>
        <li>Escena de c√°ustica: l√°mpara puntual + vaso de cristal ‚Äî comparaci√≥n PathTracer vs PhotonMapper.</li>
        <li>Escena interior con luz de √°rea: pruebas de MIS y NEE.</li>
        <li>Escena con niebla: demostraci√≥n de medios homog√©neos y attenuaci√≥n.</li>
      </ul>
    </section>

    <section class="content-section">
      <h2>üìö Referencias y lecturas recomendadas</h2>
      <ul>
        <li>Pharr, Jakob, and Humphreys ‚Äî "Physically Based Rendering: From Theory to Implementation" (cap√≠tulos sobre Monte Carlo y photon mapping).</li>
        <li>Jensen ‚Äî "Realistic Image Synthesis Using Photon Mapping".</li>
        <li>Veach ‚Äî "Robust Monte Carlo Methods for Light Transport Simulation" (thesis, MIS).</li>
      </ul>
    </section>

  </main>

  <footer id="contacto">
    <div class="footer-content">
      <div class="footer-section">
        <h3 class="footer-title">Conecta conmigo</h3>
      </div>
      <div class="footer-links">
        <a href="https://github.com/J-solan" target="_blank" class="footer-link">‚Üí GitHub</a>
        <a href="https://www.linkedin.com/in/jorge-solan/" target="_blank" class="footer-link">‚Üí LinkedIn</a>
        <a href="mailto:jorgesolanmorote@gmail.com" class="footer-link">‚Üí Email</a>
      </div>
    </div>
    <div class="footer-bottom">
      <p>¬© 2025 | Jorge Sol√°n Portfolio ‚Äî Pr√°ctica Gr√°fica (Haskell)</p>
    </div>
  </footer>

  <script src="../../js/main.js"></script>
  <script src="../../js/components.js"></script>
</body>
</html>